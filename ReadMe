for (Card playerCard : me.getHand()) {
            // Если карта игрока не является козырем
            if (playerCard.getSuit() != trumpSuit && opponentCards != null) {
                // Пройдемся по картам оппонента 1
                for (Card opponent1Card : opponentCards) {
                    // если у игрока есть карта той же масти и ниже по рангу чем у противника
                    if (opponent1Card.getRank() == playerCard.getRank()) {
                        // Проверим, есть ли у игрока карта той же масти и рангом ниже, чем у найденной карты оппонента 1
                        for (Card playerCard2 : me.getHand()) {
                            if(!Card.compareCards(playerCard,playerCard2) && playerCard2.getSuit() == opponent1Card.getSuit()
                                    && playerCard2.getRank().ordinal() < opponent1Card.getRank().ordinal()) {
                                // Удаляем выбранную карту из руки игрока
                                me.getHand().remove(playerCard2);
                                return playerCard2;
                            }
                        }
                    }
                }
            }
        }










        package strategy;
        import cardPack.Card;
        import cardPack.Deck;
        import cardPack.Rank;
        import mainGame.HelpingMethods;
        import mainGame.Player;
        import cardPack.Suit;
        import mainGame.Table;
        import java.util.*;
        import static mainGame.HelpingMethods.*;
        public class SmartStrategy implements IStrategy {
            private String nameStrayegy = "Продвинутый уровень игры";
            private List<Card> cardsOut;
            public String getNameStrategy() {
                return nameStrayegy;
            }
            private Suit trumpSuit;
            public void setTrumpSuit(Suit trumpSuit) {
                this.trumpSuit = trumpSuit;
            }
            public Card attack(Player me, List<Card> opponentCards, Table table) {
                me.setHand(sortHand(me.getHand(),trumpSuit));
                if (table.getDeck().getCards().isEmpty()){//todo здесь обрабатывать ситуации, когда в колоде нет карт, исходить из парадигмы
                    List <Card> hhh = new Deck().getCards();
                    hhh.removeAll(table.cardsOut);//
                    hhh.removeAll(me.getHand());
                    switch (table.players.size()){
                        case 2:
                            if(me.getHand().size()==1){
                                System.out.println("у меня одна карта ее и выброшу");
                                return me.getHand().remove(0);
                            }
                            if(hhh.size()==1){
                                System.out.println("у него одна карта попробую закдиать его");
                                for(Card j:me.getHand()){
                                    if(HelpingMethods.canBeatCard(hhh.get(0),j,trumpSuit)){
                                        me.getHand().remove(j);
                                        return j;
                                    }
                                }
                            }
                            if(me.getHand().size() ==2 ){
                                System.out.println("у меня две  картs  и выброшу cfve. cbkmye.");
                                for(Card card1 : me.getHand()){
                                    for(Card card2:hhh){
                                        if(!HelpingMethods.canBeatCard(card2,card1,trumpSuit)){
                                            me.getHand().remove(card1);
                                            return card1;
                                        }
                                    }
                                }
                                return me.getHand().remove(1);
                            }


                            List<Card> cardsInTable = new ArrayList<>();
                            for(Card card1 : me.getHand()){
                                me.getHand().remove(card1);
                                for(Card card2:hhh){
                                    hhh.remove(card2);
                                    if(HelpingMethods.canBeatCard(card2,card1,trumpSuit)
                                            && (HelpingMethods.getUniqueRanks(me.getHand()).contains(card2.getRank())
                                            || HelpingMethods.getUniqueRanks(me.getHand()).contains(card1.getRank())) ){//если карта 2 бьети карту 1 и появляется возможность подбросить
                                        cardsInTable.add(card1);
                                        cardsInTable.add(card2);
                                        List<Card> posAttCards = HelpingMethods.ThrowCard(me,cardsInTable,trumpSuit);//здесь мы получаем массив карт, которые мы можем подкинуть
                                        for(Card d : posAttCards){
                                            boolean flag = true;
                                            for(Card qw : hhh) {
                                                if (HelpingMethods.canBeatCard(qw,d,trumpSuit)) {//здесь нужно ввести флаг и если он никакой не может побиться
                                                    flag = false;
                                                    hhh.remove(qw);
                                                    cardsInTable.add(qw);
                                                    cardsInTable.add(d);
                                                    break;
                                                    //здесь можно прописать то, когда вторую подкинутую он уже побить не сможет
                                                }
                                            }
                                            if (flag){
                                                System.out.println("ЛЕГЕНДААААА");
                                                return card1;// кинуть карту, которую побьют так, чтобы я мог кинуть карту, которую он не побьет
                                            }else{
                                                me.getHand().remove(d);
                                                posAttCards = HelpingMethods.ThrowCard(me,cardsInTable,trumpSuit);
                                                for(Card dd:posAttCards){
                                                    for(Card n:hhh){
                                                        if(!HelpingMethods.canBeatCard(n,dd,trumpSuit)){
                                                            return card1;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                me.getHand().add(card1);
                                me.setHand(sortHand(me.getHand(),trumpSuit));

                            }
                            return me.getHand().remove(0);
                        default:
                            return me.getHand().remove(0);
                    }
                }
                return me.getHand().remove(0);
            }
            public Card deff(Player me, Card recaptureCard, Table table, List<Card> cardsInTable){// стандартный алгоритм
                List <Card> hhh = new Deck().getCards();
                hhh.removeAll(table.cardsOut);//
                hhh.removeAll(me.getHand());
                /*

                 */
                double i = 0.3612;
                if ((double) (table.getDeck().getCards().size() + table.cardsOut.size()) /36>0.34){ //если в выбывших +

                }
                List<Card> possibleCardsToPlay = new ArrayList<>();
                // Создаем список карт, которыми можно побить карту recaptureCard
                for (Card card : me.getHand()) {
                    if (canBeatCard(card, recaptureCard, trumpSuit)) {
                        possibleCardsToPlay.add(card);
                    }
                }
                if (!possibleCardsToPlay.isEmpty()) {
                    me.getHand().remove(possibleCardsToPlay.get(0));
                    return possibleCardsToPlay.get(0);
                } else {
                    return null; // Если нет подходящих карт, вернуть null
                }

            }
            public Card throwCard(Player me, List<Card> desc, List<Player> players, List<Card> cardsOut) {
                List<Card> possibleCards = new ArrayList<>();
                Set<Rank> unRanks = getUniqueRanks(desc);
                for (Card card : me.getHand()) {
                    if (unRanks.contains(card.getRank())) {
                        possibleCards.add(card);
                    }
                }
                possibleCards = sortHand(possibleCards, trumpSuit);
                for (Card card : possibleCards) {
                    if (me.getHand().indexOf(card) + 1 / me.getHand().size() < 0.68) {
                        me.getHand().remove(card);
                        return card;
                    }
                    if (me.getHand().size() == 1){
                        System.out.println("подбрасываю и выхожу");
                        me.getHand().remove(card);
                        return card;
                    }
                }
                if (players.size()==2 && cardsOut.size()>=24){
                    for (Card card : possibleCards) {
                        me.getHand().remove(card);
                        return card;
                    }
                }
                return null;
            }
            public boolean areThrowCard(Player me, List<Card> desc, List<Player> players, List<Card> cardsOut) {
                List<Card> possibleCards = new ArrayList<>();
                Set<Rank> unRanks = getUniqueRanks(desc);
                for (Card card : me.getHand()) {
                    if (unRanks.contains(card.getRank())) {
                        possibleCards.add(card);
                    }
                }
                possibleCards = sortHand(possibleCards, trumpSuit);
                for (Card card : possibleCards) {
                    if (me.getHand().indexOf(card) + 1 / me.getHand().size() < 0.68) {
                        return true;
                    }
                    if (me.getHand().size() == 1){
                        System.out.println("подбрасываю и выхожу");
                        return true;
                    }
                }
                if (players.size()==2 && cardsOut.size()>=24){
                    for (Card card : possibleCards) {
                        return true;
                    }
                }
                return false;
            }
            public Card deff2(Player me, Card recaptureCard,  Table table) {
                List<Card> opponentCards = me.getOpponentsCards(table.players);
                if(opponentCards.isEmpty()){
                    return deff2(me,recaptureCard, table);
                }
                List<Card> possibleCardsToPlay = new ArrayList<>();
                // Создаем список карт, которыми можно побить карту recaptureCard
                for (Card card : me.getHand()) {
                    if (canBeatCard(card, recaptureCard, trumpSuit)) {
                        possibleCardsToPlay.add(card);
                    }
                }
                Comparator<Card> cardComparator = new Comparator<Card>() { // Создаем компаратор для сортировки по количеству карт у оппонентов с тем же рангом
                    @Override
                    public int compare(Card card1, Card card2) {
                        int count1 = cardsWithRank(card1, opponentCards).size();
                        int count2 = cardsWithRank(card2, opponentCards).size();
                        return Integer.compare(count1, count2);
                    }
                };
                // Сортируем массив возможных карт для хода
                possibleCardsToPlay = sortHand(possibleCardsToPlay,trumpSuit);
                Collections.sort(possibleCardsToPlay, cardComparator);
                if (!possibleCardsToPlay.isEmpty()) {
                    me.getHand().remove(possibleCardsToPlay.get(0));
                    return possibleCardsToPlay.get(0); // Возвращаем карту с наименьшим количеством карт у оппонентов с тем же рангом
                } else {
                    return null; // Если нет подходящих карт, вернуть null
                }
            }
        }













package strategy;
import cardPack.Card;
import cardPack.Deck;
import cardPack.Rank;
import mainGame.HelpingMethods;
import mainGame.Player;
import cardPack.Suit;
import mainGame.Table;
import java.util.*;
import static mainGame.HelpingMethods.*;
public class SmartStrategy implements IStrategy {
    private String nameStrayegy = "Продвинутый уровень игры";
    private List<Card> cardsOut;
    public String getNameStrategy() {
        return nameStrayegy;
    }
    private Suit trumpSuit;
    public void setTrumpSuit(Suit trumpSuit) {
        this.trumpSuit = trumpSuit;
    }
    public Card attack(Player me, Player defPlayer, Table table) {
        me.setHand(sortHand(me.getHand(),trumpSuit));
        if (table.getDeck().getCards().isEmpty()){//todo здесь обрабатывать ситуации, когда в колоде нет карт, исходить из парадигмы
            List <Card> hhh = new Deck().getCards();

            hhh.addAll(defPlayer.getHand());
            System.out.println("карты противника "+ hhh.size());
            switch (table.players.size()){
                case 2:
                    if(me.getHand().size()==1){
                        System.out.println("у меня одна карта ее и выброшу");
                        return me.getHand().remove(0);
                    }
                    if(hhh.size()==1){
                        System.out.println("у него одна карта попробую закдиать его");
                        for(Card j:me.getHand()){
                            if(HelpingMethods.canBeatCard(hhh.get(0),j,trumpSuit)){
                                me.getHand().remove(j);
                                return j;
                            }
                        }
                    }
                    if(me.getHand().size() == 2){
                        System.out.println("у меня две  картs  и выброшу cfve. cbkmye.");
                        for(Card card1 : me.getHand()){
                            for(Card card2:hhh){
                                if(!HelpingMethods.canBeatCard(card2,card1,trumpSuit)){
                                    me.getHand().remove(card1);
                                    return card1;
                                }
                            }
                        }
                        return me.getHand().remove(1);
                    }
                    for(Card card1 : me.getHand()){
                        me.getHand().remove(card1);
                        for(Card card2:hhh){
                            List<Card> cardsInTable = new ArrayList<>();
                            if(HelpingMethods.canBeatCard(card2,card1,trumpSuit)
                                    && (HelpingMethods.getUniqueRanks(me.getHand()).contains(card2.getRank())
                                    || HelpingMethods.getUniqueRanks(me.getHand()).contains(card1.getRank())) ){//если карта 2 бьети карту 1 и появляется возможность подбросить
                                cardsInTable.add(card1);
                                cardsInTable.add(card2);
                                List<Card> posAttCards = HelpingMethods.ThrowCard(me,cardsInTable,trumpSuit);
                                for(Card d : posAttCards){
                                    hhh.remove(card2);
                                    boolean flag = true;
                                    for(Card qw : hhh) {
                                        if (HelpingMethods.canBeatCard(qw,d,trumpSuit)) {//здесь нужно ввести флаг и если он никакой не может побиться
                                            flag = false;
                                            hhh.remove(qw);
                                            break;
                                            //здесь можно прописать то, когда вторую подкинутую он уже побить не сможет
                                        }
                                    }
                                    if (flag){
                                        System.out.println("ЛЕГЕНДААААА");
                                        return card1;// кинуть карту, которую побьют так, чтобы я мог кинуть карту, которую он не побьет
                                    }else{

                                    }
                                }
                            }
                        }
                        me.getHand().add(card1);
                    }
                    return me.getHand().remove(0);
                default:
                    return me.getHand().remove(0);
            }
        }
        return me.getHand().remove(0);
    }
    public Card deff(Player me, Card recaptureCard, Table table, List<Card> cardsInTable){// стандартный алгоритм
        List <Card> hhh = new Deck().getCards();
        hhh.removeAll(table.cardsOut);//
        hhh.removeAll(me.getHand());
        /*

         */
        double i = 0.3612;
        if ((double) (table.getDeck().getCards().size() + table.cardsOut.size()) /36>0.34){ //если в выбывших +

        }
        List<Card> possibleCardsToPlay = new ArrayList<>();
        // Создаем список карт, которыми можно побить карту recaptureCard
        for (Card card : me.getHand()) {
            if (canBeatCard(card, recaptureCard, trumpSuit)) {
                possibleCardsToPlay.add(card);
            }
        }
        if (!possibleCardsToPlay.isEmpty()) {
            me.getHand().remove(possibleCardsToPlay.get(0));
            return possibleCardsToPlay.get(0);
        } else {
            return null; // Если нет подходящих карт, вернуть null
        }

    }
    public Card throwCard(Player me, List<Card> desc, List<Player> players, List<Card> cardsOut) {
        List<Card> possibleCards = new ArrayList<>();
        Set<Rank> unRanks = getUniqueRanks(desc);
        for (Card card : me.getHand()) {
            if (unRanks.contains(card.getRank())) {
                possibleCards.add(card);
            }
        }
        possibleCards = sortHand(possibleCards, trumpSuit);
        for (Card card : possibleCards) {
            if (me.getHand().indexOf(card) + 1 / me.getHand().size() < 0.68) {
                me.getHand().remove(card);
                return card;
            }
            if (me.getHand().size() == 1){
                System.out.println("подбрасываю и выхожу");
                me.getHand().remove(card);
                return card;
            }
        }
        if (players.size()==2 && cardsOut.size()>=24){
            for (Card card : possibleCards) {
                me.getHand().remove(card);
                return card;
            }
        }
        return null;
    }
    public boolean areThrowCard(Player me, List<Card> desc, List<Player> players, List<Card> cardsOut) {
        List<Card> possibleCards = new ArrayList<>();
        Set<Rank> unRanks = getUniqueRanks(desc);
        for (Card card : me.getHand()) {
            if (unRanks.contains(card.getRank())) {
                possibleCards.add(card);
            }
        }
        possibleCards = sortHand(possibleCards, trumpSuit);
        for (Card card : possibleCards) {
            if (me.getHand().indexOf(card) + 1 / me.getHand().size() < 0.68) {
                return true;
            }
            if (me.getHand().size() == 1){
                System.out.println("подбрасываю и выхожу");
                return true;
            }
        }
        if (players.size()==2 && cardsOut.size()>=24){
            for (Card card : possibleCards) {
                return true;
            }
        }
        return false;
    }
    public Card deff2(Player me, Card recaptureCard,  Table table) {
        List<Card> opponentCards = me.getOpponentsCards(table.players);
        if(opponentCards.isEmpty()){
            return deff2(me,recaptureCard, table);
        }
        List<Card> possibleCardsToPlay = new ArrayList<>();
        // Создаем список карт, которыми можно побить карту recaptureCard
        for (Card card : me.getHand()) {
            if (canBeatCard(card, recaptureCard, trumpSuit)) {
                possibleCardsToPlay.add(card);
            }
        }
        Comparator<Card> cardComparator = new Comparator<Card>() { // Создаем компаратор для сортировки по количеству карт у оппонентов с тем же рангом
            @Override
            public int compare(Card card1, Card card2) {
                int count1 = cardsWithRank(card1, opponentCards).size();
                int count2 = cardsWithRank(card2, opponentCards).size();
                return Integer.compare(count1, count2);
            }
        };
        // Сортируем массив возможных карт для хода
        possibleCardsToPlay = sortHand(possibleCardsToPlay,trumpSuit);
        Collections.sort(possibleCardsToPlay, cardComparator);
        if (!possibleCardsToPlay.isEmpty()) {
            me.getHand().remove(possibleCardsToPlay.get(0));
            return possibleCardsToPlay.get(0); // Возвращаем карту с наименьшим количеством карт у оппонентов с тем же рангом
        } else {
            return null; // Если нет подходящих карт, вернуть null
        }
    }
}
